#+TITLE: Calculating bidirectional type systems
#+ALIAS: calc-bidir

* From an existing undirected [[type system]]

Using [[list comprehensions]].

- TODO: "by definition of Γ ⊢ T : τ" is technically speaking "by inversion" of it.
  How does this technique play with type systems where the inversion gives us an
  "or"? i.e., if there are two rules by which we can type a term.



Given a relation Γ ⊢ T : τ, it's natural to want to derive a type inference
function `infer :: Γ -> Expr -> Type` which has "the same behaviour". Not every
expression has a type though, so we can return a list instead to indicate the
possibility of failure.

#+BEGIN_SRC hs
infer :: Γ -> Expr -> [Type]
  -- such that
correctness = infer Γ x ⊆ [ τ | Γ ⊢ x : τ ]
#+END_SRC

Let's try some calculations:

** Case: I n and B b
#+BEGIN_SRC hs
[ τ | Γ ⊢ I n : τ ]
  = {- by definition of Γ ⊢ T : τ -}
[ INT ]
  = {- define: -}
infer Γ (I n).
#+END_SRC

Exactly the same for booleans, giving us:
#+BEGIN_SRC hs
infer Γ (B b) = [BOOL]
#+END_SRC

** Case: Var i
#+BEGIN_SRC hs
[ τ | Γ ⊢ Var i : τ ]
  = {- by definition of Γ ⊢ T : τ -}
[ τ | (i, τ) ∈ Γ ]
  = {- definition of ∈ -}
[ τ | (j, τ) <- Γ, i == j ]
  = {- define: -}
infer e (Var i).
#+END_SRC

*** The 'definition of ∈' step
Given
#+BEGIN_SRC hs
(∈) :: Eq a => a -> [a] -> Bool
x ∈ xs = not (null [ x | y <- xs, x == y ])

-- then
(i, τ) ∈ Γ
  = {- definition -}
not (null [ (i, τ) | (j, σ) <- Γ, (i, j) == (τ, σ) ])
  = {- definition of == -}
not (null [ (i, τ) | (j, σ) <- Γ, i == j, τ == σ ])
  = {- substitute via τ == σ -}
not (null [ (i, τ) | (j, τ) <- Γ, i == j ])

-- and so:
[ τ | (i, τ) ∈ Γ ]
  = {- by above -}
[ τ | not (null [ (i, τ) | (j, τ) <- Γ, i == j ]) ]
  = {- list comprehension ~= not null -}
[ τ | (k, σ) <- [ (i, τ) | (j, τ) <- Γ, i == j ] ]
  = {- collapse (actually an instance of monad left-return law) -}
[ τ | (i, σ) <- Γ, i == j ]
#+END_SRC

*** Alternative logic for it
Maybe cleaner to think of it like this. But we really need to think of a proper
"calculus" of calculuations, or like, what are we actually allowed to say? We
can make any transformation that is logically true, in theory. But it would be
good to not have to prove this at each point. In particular, how can we easily
show that the "reverse the condition" step there is true? In fact it's a little
unclear if it even is, as the pattern matching doesn't quite work like that.

#+BEGIN_SRC hs
[ τ | Γ ⊢ Var i : τ ]
  = {- by definition of Γ ⊢ T : τ -}
[ τ | (i, τ) ∈ Γ ]
  = {- implicit universal quantification -}
[ τ | τ <- allTypes, (i, τ) ∈ Γ ]
  = {- pair the types up with i -}
[ τ | (i, τ) <- [ (i, σ) | σ <- allTypes ], (i, τ) ∈ Γ ]
  = {- reverse the condition -}
[ τ | (i, τ) <- Γ, (i, τ) ∈ [ (i, σ) | σ <- allTypes ] ]
  = {- trivial condition; all types are in allTypes -}
[ τ | (i, τ) <- Γ ]
  = {- can't pattern match like this, so write as == -}
[ τ | (j, τ) <- Γ, i == j ]
#+END_SRC

** Case: If x y z
#+BEGIN_SRC hs
[ τ | Γ ⊢ If x y z : τ ]
  = {- by definition of Γ ⊢ T : τ -}
[ τ | Γ ⊢ x : BOOL, Γ ⊢ y : τ, Γ ⊢ z : τ ]
  = {- relation -}
[ τ | BOOL ∈ [ u | Γ ⊢ x : u ], Γ ⊢ y : τ, Γ ⊢ z : τ ]
  ⊇ {- (x ∈ X) and (X ⊆ Y) implies (x ∈ Y); induction on x -}
[ τ | BOOL ∈ infer Γ x, Γ ⊢ y : τ, Γ ⊢ z : τ ]
  ⊇ {- same for y and z -}
[ τ | BOOL ∈ infer Γ x, τ ∈ infer Γ y, τ ∈ infer Γ z ]
  = {- (x ∈ X) and (x ∈ Y) iff (x ∈ X ∩ Y) -}
[ τ | BOOL ∈ infer Γ x, τ ∈ (infer Γ y ∩ infer Γ z) ]
  ⊇ {- list comprehension. NOTE: i wrote this as a superset but i'm not
       sure if it actually is; is it just =? -}
[ τ | BOOL <- infer Γ x, τ <- (infer Γ y ∩ infer Γ z) ]
  = {- define: -}
infer Γ (If x y z).
#+END_SRC

** Case: App x y
#+BEGIN_SRC hs
[ τ | Γ ⊢ App x y : τ ]
  = {- by definition of Γ ⊢ T : τ -}
[ σ | Γ ⊢ x : (τ → σ), Γ ⊢ y : τ ]
  ⊇ {- induction on x and y -}
[ σ | (τ → σ) ∈ infer Γ x, τ ∈ infer Γ y ]
  ⊇ {- ∈ into <-, so that τ and σ are bound -}
[ σ | (τ → σ) <- infer Γ x, τ ∈ infer Γ y ]
  = {- define: -}
infer Γ (App x y).
#+END_SRC

** Case: Abs i x
#+BEGIN_SRC hs
[ τ | Γ ⊢ Abs i x : τ ]
  = {- by definition of Γ ⊢ T : τ -}
[ τ → σ | (Γ, i:τ) ⊢ x : σ ]
  ⊇ {- induction on x -}
[ τ → σ | σ ∈ infer ((i, τ) : Γ) x ]
  ⊇ {- list comprehension -}
[ τ → σ | σ <- infer ((i, τ) : Γ) x ]
  ...?
#+END_SRC

Here's where we get stuck. There isn't much else we can do at this point, but
we're not finished, because τ is undefined. There are two possible solutions we
could consider:

*** Solution 1: Add τ to the constructor

Like the `PUSH instruction in [[compiler calculations]], we could simply modify
the `Abs constructor to hold on to τ for us. Then,
#+BEGIN_SRC hs
[ σ | Γ ⊢ Abs i τ x : σ ]
  = {- by definition of Γ ⊢ T : σ -}
[ τ → σ | (Γ, i:τ) ⊢ x : σ ]
  ⊇ {- induction on x -}
[ τ → σ | σ ∈ infer ((i, τ) : Γ) x ]
  ⊇ {- list comprehension -}
[ τ → σ | σ <- infer ((i, τ) : Γ) x ]
  = {- define: -}
infer Γ (Abs i τ x).
#+END_SRC
This is not particularly satisfying though as it would require a lot of
explicit type annotations. This is the [[simply typed lambda calculus]].

*** Solution 2: Add τ as a parameter to inference

Taking things very literally, the simplest way to store τ as an extra parameter
is to work with another function, `infer' Γ e τ`. The τ parameter tells us the
type of the input to the function, if e does happen to be a function. It is
natural to extend this to lists of inputs of any length including zero.

#+BEGIN_SRC hs
infer' :: Env -> Expr -> [Type] -> [Expr]
correctness = infer' Γ x [τ₁,τ₂,...] ⊆ [ τ₁ → ... → σ | Γ ⊢ x : (τ₁ → ... → σ) ]

[ τ₁ → ... → σ | Γ ⊢ Abs i x : (τ₁ → ... → σ) ]
  =
[ τ₁ → ... → σ | (Γ, i:τ₁) ⊢ x : (τ₂ → ... → σ) ]
  =
[ τ₁ → ... → σ | (τ₂ → ... → σ) ∈ infer' ((i, τ₁) : Γ) x [τ₂, ...] ]
  =
infer' Γ (Abs i x) [τ₁, τ₂, ...]
#+END_SRC

**** Recovering normal inference
Given the correctness equation above we can recover `infer`:

#+BEGIN_SRC hs
infer Γ x = infer' Γ x []
#+END_SRC

**** Other syntax; where do annotations come in?

Does this work for the other syntax?

#+BEGIN_SRC hs
[ τ₁ → ... → σ | Γ ⊢ I n : (τ₁ → ... → σ) ]
  = {- can only be INT -}
[ INT ]
  = {- define: -}
infer' Γ (I n) []
#+END_SRC

We have to "put the type" somewhere, though. We've said that we will add the
input types to `infer'`, but where does this come from? It would be annotations,
but it's not clear how to get these naturally.

*** Solution 3: Like above, but less weird

Remember the problem we had, getting stuck here.

#+BEGIN_SRC hs
[ τ | Γ ⊢ Abs i x : τ ]
  = {- by definition of Γ ⊢ T : τ -}
[ τ → σ | (Γ, i:τ) ⊢ x : σ ]
  ⊇ {- induction on x -}
[ τ → σ | σ ∈ infer ((i, τ) : Γ) x ]
  ⊇ {- list comprehension -}
[ τ → σ | σ <- infer ((i, τ) : Γ) x ]
  ...?
#+END_SRC

τ is undefined. If we didn't make the last step, "list comprehension", then we
can see that σ is also undefined. In this case it might make sense to package
both of them up as an argument to inference; the whole type.

That is, work with a new function `check`, which we use to infer the type of
abstractions.
#+BEGIN_SRC hs
check :: Env -> Expr -> Type -> [Expr]
correctness = check Γ x (τ → σ) ⊆ [ τ → σ | Γ ⊢ x : τ → σ ]
#+END_SRC

In doing this, τ and σ are now defined, and so the calculation would be okay.
Also note that it doesn't really matter that it's (τ → σ) now. We can define
#+BEGIN_SRC hs
correctness' = check Γ x τ ⊆ [ τ | Γ ⊢ x : τ ]
  -- i.e. to spell it out more explicitly:
correctness' = check Γ x τ ⊆ [ τ' | Γ ⊢ x : τ', τ == τ' ]
  -- and we know that by definition:
  -- correctness' implies correctness
#+END_SRC

Doing the calculation again:
#+BEGIN_SRC hs
[ τ | Γ ⊢ Abs i x : τ ]
  = {- by definition of Γ ⊢ T : τ -}
[ τ → σ | (Γ, i:τ) ⊢ x : σ ]
  ⊇ {- induction on x -}
[ τ → σ | σ ∈ check ((i, τ) : Γ) x σ ]
  ⊇ {- list comprehension -}
[ τ → σ | σ <- check ((i, τ) : Γ) x σ ]
  = {- define: -}
check Γ (Abs i x) (τ → σ).
#+END_SRC

What about for the other constructors? We still have
#+BEGIN_SRC hs
infer :: Γ -> Expr -> [Type]
  -- such that
correctness = infer Γ x ⊆ [ τ | Γ ⊢ x : τ ]
#+END_SRC

So let's try generally for any x.

#+BEGIN_SRC hs
[ τ | Γ ⊢ x : τ ]
  ⊇ {- correctness of infer -}
infer Γ x
  ⊇ {- subset -}
[ τ' | τ' <- infer Γ x, τ' == τ ]
  = {- define: -}
check Γ x t
#+END_SRC

This is great, as it's exactly what we expect (it's the CheckInfer rule). So
the last question is where annotations should come from...

Maybe if we want to recover `infer` entirely from `check`?

#+BEGIN_SRC hs
infer :: Γ -> Expr -> [Type]
check :: Env -> Expr -> Type -> [Expr]
  -- such that
correctness = infer Γ x ⊆ [ τ | Γ ⊢ x : τ ]
correctness = check Γ x τ ⊆ [ τ' | Γ ⊢ x : τ, τ == τ' ]
  -- define a new
infer' :: Γ -> Expr -> [Type]
infer Γ e ⊆ infer' Γ e -- tells us more than inference alone
infer' Γ e ⊆ [ σ | τ <- allTypes, σ ← check Γ e τ ] -- is still correct
#+END_SRC

The most obvious solution here would be just copying over `infer` or this
`check` definition. I.e. defining either:
#+BEGIN_SRC hs
infer' Γ e = infer Γ e
  -- or
infer' Γ e = [ σ | τ <- allTypes, σ ← check Γ e τ ]
#+END_SRC
The latter is not really possible though as `allTypes` is not defined. We could
define it but it would be an infinite list, and our type inference would then
never terminate. The former is not ideal either, as we are not gaining anything.

We can do the same trick as before, pulling out an unknown into a constructor.
#+BEGIN_SRC hs
data Expr
  = ...
  | Ann Expr [Type]

infer' Γ (Ann e τs) = [ σ | τ <- τs, σ ← check Γ e τ ]
#+END_SRC
We wanted this to be independent of `check` and `infer` though, so we can run
the calculations through and end up with:
#+BEGIN_SRC hs
infer' :: Env -> Expr -> [Type]
infer' e (Ann x t) = check e x t
infer' e (Var x) = [ t | (x', t) <- e, x == x' ]
infer' _ (LitInt _) = [INT]
infer' _ (LitBool _) = [BOOL]
infer' e (If x y z) = [ t | BOOL <- infer' e x, t <- infer' e y ∩ infer' e z ]
infer' e (App x y) = [ t2 | (FN t1 t2) <- infer' e x, t1 ∈ infer' e y ]
infer' e (Abs i x) = []

check' :: Env -> Expr -> Type -> [Type]
check' e (Abs i x) (FN t u) = [FN t u | u' <- check' ((i, t) : e) x u, u == u']
check' e x t = [t' | t' <- infer' e x, t == t']
#+END_SRC

TODO: check that we do actually get these definitions if we do the calculations.

*** (Solution 4: Make a new type which we can use as a placeholder)

[[polymorphism]]
